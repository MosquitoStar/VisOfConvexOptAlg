<!DOCTYPE html>
<html style="height: 100%">

<head>
    <meta charset="utf-8">
</head>


<body>

    <!-- <script src="https://d3js.org/d3.v5.min.js"></script> -->
    <!-- use local d3.js script file -->
    <script src="d3/d3.min.js"></script> 

    <div id="canvas"></div>

    <table>
        <tr>
            <th style="width: 10px;font-size: 10px;">x:</th>
            <td id="curx" style="width: 120px;font-size: 10px;">0.0</td>
            <th style="width: 10px;font-size: 10px;">y:</th>
            <td id="cury" style="width: 120px;font-size: 10px;">0.0</td>
            <th style="width: 10px;font-size: 10px;">f:</th>
            <td id="curf" style="width: 120px;font-size: 10px;">0.0</td>
        </tr>
    </table>

    <script type="text/javascript">

        // quandratic bowl function
        function quad_bowl(x, y){
            var a = 3, b = 5, c = 0.1, d = 0.4;
            return x * x + y * y - a * Math.exp(-((x - 1) * (x - 1) + y * y) / c) - b * Math.exp(-((x + 1) * (x + 1) + y * y) / d);
            return Math.sqrt(x * x + y * y);
        }

        // gradient of quandratic bowl function 
        function quad_bowl_grad(x, y){
            var a = 3, b = 5, c = 0.1, d = 0.4;
            var px = 2 * x - a * (-2 / c * (x - 1)) * Math.exp(-((x - 1) * (x - 1) + y * y) / c) - b * (-2 / d * (x + 1)) * Math.exp(-((x + 1) * (x + 1) + y * y) / d);
            var py = 2 * y - a * (-2 / c * y) * Math.exp(-((x - 1) * (x - 1) + y * y) / c) - b * (-2 / d * y) * Math.exp(-((x + 1) * (x + 1) + y * y) / d);
            return [px, py];
        }

        // the function in tutorial 7
        function t7f(x, y){
            var gamma = 2;
            return 0.5 * (x * x + 2 * y * y);
        }

        // gradient of the function in tutorial 7
        function t7f_grad(x, y){
            var gamma = 2;
            return [x, gamma * y];
        }

        // function to visualize and optimize
        var f = t7f;
        var f_grad = t7f_grad;

        // steepest descent method
        function steepest_descent(x, y){
            var gamma = 2;
            var epsilon = 0.0001;
            var maxiter = 1000;
            var numiter = 1;
            var curx = x, cury = y;
            var f_prev = f(curx, cury);
            var traj = new Array();
            traj.push([curx, cury]);
            while (numiter < maxiter) {
                var gradient = f_grad(curx, cury);
                var deltax = -gradient[0];
                var deltay = -gradient[1];
                var t = (curx * curx + gamma * gamma * y * y) / (curx * curx + gamma * gamma * gamma * y * y);
                curx += t * deltax;
                cury += t * deltay;
                traj.push([curx, cury]);
                if(Math.abs(f(curx, cury) - f_prev) < epsilon){
                    break;
                }
                f_prev = f(curx, cury);
                numiter++;
            }
            // return [curx, cury];
            return traj;
        }

        // Newton method
        function newton(x, y){
            var gamma = 2;
            var epsilon = 0.0001;
            var maxiter = 1000;
            var numiter = 1;
            var curx = x, cury = y;
            var traj = new Array();
            traj.push([curx, cury]);
            while(numiter < maxiter){
                var deltax = -curx;
                var deltay = -gamma * gamma * cury;
                var t = 0.1;
                curx += t * deltax;
                cury += t * deltay;
                traj.push([curx, cury]);
                if(curx * curx + gamma * gamma * gamma * cury * cury <= epsilon){
                    break;
                }
                numiter++;
            }
            // return [curx, cury];
            return traj;
        }

        // svg element
        var s = d3.select("#canvas")
                    .append("svg");
        
        // size of svg image
        var width = 600, height = 400;
        var margin = 30;
        
        // range of (x, y)
        var xmin = -3, xmax = 3;
        var ymin = -2, ymax = 2;
        
        // heatmap segmentation parameter
        var d = 100;
        var xd = width>height? d : Math.round(d * width / height);
        var yd = width>height? Math.round(d * height / width) : d;
        var dx = (xmax - xmin) / xd, dy = (ymax - ymin) / yd;
        var dw = (width - 2 * margin) / xd, dh = (height - 2 * margin) / yd;
        
        // data (stored in row-major order)
        var data = new Array();
        var mindata = Infinity, maxdata = -Infinity;
        for(var i = 0; i < xd; i++){
            data[i] = new Array();
            for(var j = 0; j < yd; j++){
                var x = xmin + dx * i;
                var y = ymin + dy * j;
                data[i][j] = f(x, y);
                mindata = Math.min(mindata, data[i][j]);
                maxdata = Math.max(maxdata, data[i][j]);
            }
        }

        // flatten data
        var dataf = new Array(xd * yd);
        for(var i = 0; i < xd; i++){
            for(var j = 0; j < yd; j++){
                dataf[i * yd + j] = data[i][j];
            }
        }

        // heatmap function
        function palette_color(v, minv, maxv){
            var palette = [
                [35, 35, 220],
                [55, 200, 55],
                [200, 200, 55],
                [200, 55, 55],
            ];
            var r, g, b;
            var valueweight = (v - minv) / (maxv - minv);
            for(var i = 0; i < palette.length - 1; i++){
                if(valueweight >= i / (palette.length - 1) && valueweight <= (i + 1) / (palette.length - 1)){
                    r = palette[i][0] + (palette[i + 1][0] - palette[i][0]) * (valueweight - i / (palette.length - 1)) * (palette.length - 1);
                    g = palette[i][1] + (palette[i + 1][1] - palette[i][1]) * (valueweight - i / (palette.length - 1)) * (palette.length - 1);
                    b = palette[i][2] + (palette[i + 1][2] - palette[i][2]) * (valueweight - i / (palette.length - 1)) * (palette.length - 1);
                }
            } 
            return {red: r, green: g, blue: b};
        }

        // set height and width 
        s.attr("width", width).attr("height", height);

        // draw function value text
        var fvalue = 0.0;
        s.append("text")
            .text(fvalue.toString())
            .attr("id", "fvalue")
            .attr("x", 0)
            .attr("y", 10)
            .style("fill", "black")
            .style("font-size", "8px");

        // draw heatmap
        s.selectAll()
            .data(dataf)
            .enter()
            .append("rect")
            .attr("x", function(d, k){
                var i = Math.floor(k / yd);
                return margin + i * dw;
            })
            .attr("y", function(d, k){
                var j = k % yd;
                return height - margin - (j + 1) * dh;
            })
            .attr("width", function(d, k){ return dw; })
            .attr("height", function(d, k){ return dh; })
            .attr("fill", function(d, k){ 
                var c = palette_color(d, mindata, maxdata);
                return "rgb(" + c.red + "," + c.green + "," + c.blue + ")"; 
            })
            .on("mouseover", function(d, k){
                fvalue = d;
                var i = Math.floor(k / yd);
                var j = k % yd;
                s.select("#fvalue")
                    .text(fvalue.toString());
                d3.select("#curx")
                    .text((xmin + i * dx).toString());
                d3.select("#cury")
                    .text((ymin + j * dy).toString());
                d3.select("#curf")
                    .text(d.toString());
            });

        // functions to transform geometric coordinates to svg coordinates
        function gtosx(x){
            return margin + (width - 2 * margin) * (x - xmin) / (xmax - xmin);
        }
        function gtosy(y){
            return height - margin + (2 * margin - height) * (y - ymin) / (ymax - ymin);
        }

        // functions to transform svg coordinates to geometric coordinates
        function stogx(x){
            return xmin + (xmax - xmin) * (x - margin) / (width - 2 * margin);
        }
        function stogy(y){
            return ymin + (ymax - ymin) * (y - height + margin) / (2 * margin - height);
        }

        // draw x axis
        s.append("line")
            .attr("x1", margin)
            .attr("y1", height - margin)
            .attr("x2", width - margin)
            .attr("y2", height - margin)
            .style("stroke", "black")
            .attr("stroke-width", "2px");

        // draw y axis
        s.append("line")
            .attr("x1", margin)
            .attr("y1", height - margin)
            .attr("x2", margin)
            .attr("y2", margin)
            .style("stroke", "black")
            .attr("stroke-width", "2px");

        // function to regulate scale
        function regulate(minv, maxv, numscale){
            if(numscale < 1 || maxv < minv){
                return;
            }
            var delta = maxv - minv;
            var exp = Math.floor(Math.log(delta) / Math.log(10)) - 2;
            var multiplier = Math.pow(10, exp);
            var solutions = [1, 2, 2.5, 5, 10, 20, 25, 50, 100, 200, 250, 500];
            var i;
            for(i = 0; i < solutions.length; i++){
                var multical = multiplier * solutions[i];
                if(Math.floor(delta / multical) + 1 <= numscale){
                    break;
                }
            }
            var interval = multiplier * solutions[i];
            var startpoint = (Math.ceil(minv / interval) - 1) * interval;
            var scale = new Array()
            var idx;
            for(idx = 0; ; idx++)
            {
                scale.push(startpoint + interval * idx);
                if(startpoint + interval * idx > maxv){
                    break;
                }
            }
            return scale;
        }

        // draw scale
        var numscale = 10;
        var numscalex = width>height? numscale : Math.round(numscale * width / height);
        var numscaley = width>height? Math.round(numscale * height / width) : numscale;
        var xscale = regulate(xmin, xmax, numscalex);
        var yscale = regulate(ymin, ymax, numscaley);
        var scalelength = 3;
        s.selectAll()
            .data(xscale)
            .enter()
            .append("line")
            .attr("x1", function(d){ return gtosx(d); })
            .attr("y1", height - margin)
            .attr("x2", function(d){ return gtosx(d); })
            .attr("y2", height - margin + scalelength)
            .style("stroke", "black")
            .attr("stroke-width", "2px");
        s.selectAll()
            .data(yscale)
            .enter()
            .append("line")
            .attr("x1", margin)
            .attr("y1", function(d){ return gtosy(d); })
            .attr("x2", margin - scalelength)
            .attr("y2", function(d){ return gtosy(d); })
            .style("stroke", "black")
            .attr("stroke-width", "2px");

        // draw scale text
        var textoffsetx_x = -3;
        var textoffsety_x = 15;
        var textoffsetx_y = -15;
        var textoffsety_y = 3;
        var textsize = 10;
        s.selectAll()
            .data(xscale)
            .enter()
            .append("text")
            .text(function(d){ return d.toString(); })
            .attr("x", function(d){
                return gtosx(d) + textoffsetx_x * d.toString().length;
            })
            .attr("y", height - margin + textoffsety_x)
            .style("fill", "black")
            .style("font-size", textsize.toString() + "px");
        s.selectAll()
            .data(xscale)
            .enter()
            .append("text")
            .text(function(d){ return d.toString(); })
            .attr("x", function(d){
                return margin + textoffsetx_y - (d.toString().length - 1) * textsize / 2;
            })
            .attr("y", function(d){
                return gtosy(d) + textoffsety_y;
            })
            .style("fill", "black")
            .style("font-size", textsize.toString() + "px");

        // set onclick function
        s.on("click", function(){
            console.log(d3.mouse(this));
            var clickpos = d3.mouse(this);
            var clickx = stogx(clickpos[0]);
            var clicky = stogy(clickpos[1]);
            console.log(clickx, clicky);
            var traj1 = steepest_descent(clickx, clicky);
            var traj2 = newton(clickx, clicky);
            console.log("steepest");
            console.log(traj1);
            console.log("newton");
            console.log(traj2);
            
            // clean former path
            s.selectAll("path").remove();

            // line generator function
            var linefunc = d3.line()
                            .x(function(d){ return gtosx(d[0]); })
                            .y(function(d){ return gtosy(d[1]); })
                            .curve(d3.curveLinear);
            
            // draw steepest descent optimization path
            s.append("path")
                .attr("d", linefunc(traj1))
                .attr("stroke", "purple")
                .attr("stroke-width", 3)
                .attr("fill", "none");
            
            // draw Newton method optimization path
            s.append("path")
                .attr("d", linefunc(traj2))
                .attr("stroke", "brown")
                .attr("stroke-width", 3)
                .attr("fill", "none");

            console.log("draw finish");
        })

    </script>


</body>

</html>